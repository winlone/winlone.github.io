---
layout: mypost
title: 使用Redux管理组件状态
categories: [前端]
---

Redux 是 JavaScript 的状态容器，提供了可预测的状态管理。一般 Redux 都是搭配 React 使用，也可以在 Vue 中使用，据说 Vuex 就是根据 Redux 来的。

React 是在视图层帮助我们解决了 DOM 的渲染过程，但是 State 依然是留给我们自己来管理。在大型项目中，React 中原始的组件间传递 props 肯定是不现实的，这时候就需要全局统一的状态管理了，同时也需要知道状态变化的过程方便调试。

redux 的三大原则：

1. 单一数据源

2. State 是只读的

3. 使用纯函数来执行修改

## 基本使用

```
npm i redux -S
```

redux 的概念非常简单，通过 subscribe 订阅 store 的更新，通过 dispatch 改变 store 后调用 reducer 函数更新 store，更新完成后触发 subscribe 订阅的回调函数。

规定 reducer 必须是一个纯函数，所谓纯函数就是确定的输入，一定会产生确定的输出，函数在执行过程中，不能产生副作用(传入一个对象时调用完毕后发生了改变，或者其他与更新状态无关的事情)，不依赖其他外部变量(const 定义的常量是可以的)

对于 reducer 必须是纯函数这一点也很好理解，确保了 reducer 函数的单一功能。所以直接修改 state 的值也是禁止的，所有对 state 的更新只能通过 dispatch 在 reducer 中完成

```js
const redux = require('redux')

const initialState = {
  name: 'default'
}

// 不需要直接修改state
function reducer(state = initialState, action) {
  switch (action.type) {
    case 'CHANGE_NAME':
      return { ...state, name: action.name }
    default:
      return state
  }
}

const store = redux.createStore(reducer)

console.log(store.getState())

store.subscribe(() => {
  console.log('store 发生了改变')
  console.log(store.getState())
})

store.dispatch({
  type: 'CHANGE_NAME',
  name: '张三'
})
```

对于上述代码，一般标准的封装方式如下。图方便我感觉再封装成 Class 会整洁一些

```
store/index.js          # 导出store
store/reducer.js        # 定义 initialState 和 reducer
store/actionCreators.js # 定义action
store/constants.js      # 定义actionName
```

```js
class Store {
  constructor() {
    this.initialState = {
      name: 'default'
    }
    this.store = redux.createStore(this.reducer)
  }

  subscribe = callback => this.store.subscribe(callback)
  getState = () => this.store.getState()
  dispatch = action => this.store.dispatch(action)
  reducer = (state = this.initialState, action) => {
    switch (action.type) {
      case 'CHANGE_NAME':
        return { ...state, name: action.name }
      default:
        return state
    }
  }

  changeName(name) {
    this.dispatch({
      type: 'CHANGE_NAME',
      name: name
    })
  }
}

const store = new Store()

console.log(store.getState())

store.subscribe(() => {
  console.log('store 发生了改变')
  console.log(store.getState())
})

store.changeName('张三')
```

## 针对业务进行拆分

如果在一个 reducer 函数中定义所有的 action 会显得臃肿，可以根据业务拆分为多个 reducer 函数，然后合并为一个 reducer

```js
const initialState = {}
const initialOrder = { money: 100 }

function orderReducer(state = initialOrder, action) {
  switch (action.type) {
    case 'CHANGE_MONEY':
      return { ...state, money: action.value }
    default:
      return state
  }
}

function reducer(state = initialState, action) {
  return {
    orderInfo: orderReducer(state.orderInfo, action)
  }
}

const store = redux.createStore(reducer)

export { store }
```

## 在 React 中使用

在 React 中组件的更新都是通过 setState 触发组件更新。通过上面的使用，可以很容易的写出如下代码：

```
setState -> UI
redux -> setState -> UI
```

由于使用 Vuex 习惯了，喜欢使用`$store`命名，图方便直接使用整个 state，一般都是只取出 state 的部分值放到组件的 state 中

```
class App2 extends React.Component {
  constructor(props) {
    super(props)
    this.state = {
      $store: store.getState()
    }
    this.unsubscribe = null
  }
  componentDidMount() {
    this.unsubscribe = store.subscribe(() => this.setState({ ...this.state, $store: store.getState() }))
  }
  componentWillUnmount() {
    this.unsubscribe()
  }
  render(h) {
    return (
      <div>
        <span>APP2:</span>
        <span>{this.state.$store.name}</span>
      </div>
    )
  }
}
```

通过上述代码不难发现，在每个组件中使用 Redux 的步骤都是一样的，每个组件都这样写会显得有些冗余，可以考虑使用高阶组件对组件进行封装。

```js
function Wrap(C) {
  return class extends React.Component {
    constructor(props) {
      super(props)
      this.state = {
        $store: store.getState()
      }
      this.unsubscribe = null
    }
    componentDidMount() {
      this.unsubscribe = store.subscribe(() => {
        return this.setState({ $store: store.getState() })
      })
    }
    componentWillUnmount() {
      this.unsubscribe()
    }
    render() {
      return <C {...this.props} {...this.state}></C>
    }
  }
}
```

```js
let WrapedApp2 = Wrap(App2)

render(h) {
  let WrapedApp2 = Wrap(App2)
  return (
    <div className="App">
      <WrapedApp2></WrapedApp2>
    </div>
  )
}
```

## react-redux

上述通过封装高阶组件的方式消除了代码冗余，其实官方提供了 react-redux，建议用官方实现的。还有上面实现的 Wrap 还有一个外部依赖 store，在 react-redux 中通过 Context 来传递 store

声明两个方法，表示那些 state 的属性暴露出去，那些 action 方法暴露出去

```js
function mapStateToProps(state) {
  return { ...state }
}

function mapDispatchToProps(dispatch, ownProps) {
  return { changeName: changeName }
}
```

mapStateToProps，mapDispatchToProps 两个方法的返回值会解构在 App2 的 props 上

```js
import { connect, Provider } from 'react-redux'

render(h) {
  let WrapedApp2 = connect(mapStateToProps, mapDispatchToProps)(App2)
  return (
    <Provider store={store}>
      <div className="App">
        <WrapedApp2></WrapedApp2>
      </div>
    </Provider>
  )
```

```js
class App2 extends React.Component {
  change = () => {
    this.props.changeName('Hello ' + this.props.name)
  }
  render(h) {
    return (
      <div onClick={this.change}>
        <span>APP2:</span>
        <span>{this.props.name}</span>
      </div>
    )
  }
}
```

## redux 中间件

redux 有中间件的功能，可以在 dispatch 和 reducer 之间扩展代码。比如实现在每次 dispatch 时候打印出前后的值就可以通过中间件来实现

```js
function logger(store) {
  return next => {
    return action => {
      console.log('before', store.getState())
      console.log('do', action)
      let result = next(action)
      console.log('after', store.getState())
      return result
    }
  }
}

// const store = redux.createStore(reducer)
const store = redux.createStore(reducer, redux.applyMiddleware(logger))
```

## redux-thunk

redux-thunk 是一个中间件，默认情况下的 dispatch(action) 必须传入一个对象，使用 redux-thunk 中间件后可以让 action 为一个函数。redux-thunk 会自动往这个函数上添加 dispatch, getState。一般是用来减少在组件的 componentDidMount 中去调用网络请求再提交到 redux 状态中，通过 redux-thunk 可以直接提交了

```
npm install --save redux-thunk
```

```js
import thunk from 'redux-thunk'

const store = redux.createStore(reducer, redux.applyMiddleware(thunk, logger))

function mockAjax(param) {
  return (dispatch, getState) =>
    // ajax url param
    new Promise((resolve, reject) => {
      resolve('xxx')
    }).then(data => {
      dispatch({
        type: 'CHANGE_NAME',
        name: data
      })
    })
}

function loadData() {
  store.dispatch(mockAjax({ param: 'xxx' }))
}
```

## 其他中间件

- redux-devtools

- redux-saga
